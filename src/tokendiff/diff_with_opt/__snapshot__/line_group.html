<!DOCTYPE html>
<html>
<head>
<style>

  del {
    background-color: #ffe6e6;
    color: #c00;
    text-decoration: line-through;
  }

  ins {
    background-color: #e6ffe6;
    color: #008000;
    text-decoration: none;
  }

  pre {
    background-color: #f4f4f4;
    padding: 1em;
    border-radius: 5px;
    white-space: pre-wrap;
  }
  code {
    font-family: 'Courier New', Courier, monospace;
  }
</style>
</head>
<body>
<pre><code>
///|UUID(e9c1b971-0da7-425d-87f6-520910e5a22b)
pub fn line_group(old : String, new : String) -> Array[REdit] {
  let groups = Array::new()
  let mut old = old.split("\n").collect()[:]
  while old is [.. rest, ""] {
    old = rest
  }
  let mut new = new.split("\n").collect()[:]
  while new is [.. rest, ""] {
    new = rest
  }
  let mut edits = @compress.compress_edits(@myers.diff(old~, new~))[:]
  if edits
    is ([Delete(old~), Insert(new~), .. rest]
    | [Insert(new~), Delete(old~), .. rest]) {
    groups.push(REdit::Replace(old~, new~))
    edits = rest
  }
  while true {
    match edits {
      [] => break
      [Delete(old~), Insert(new~)] | [Insert(new~), Delete(old~)] => {
        groups.push(REdit::Replace(old~, new~))
        break
      }
      [
        Equal(..) as prev,
        Insert(new~),
        Delete(old~),
        <del>Equal(..) as next,</del>
        .. rest<del>,</del>
      ]
      | [
        Equal(..) as prev,
        Delete(old~),
        Insert(new~)<del>,
        Equal(..)</del> <del>as next</del>,
        .. rest<del>,</del>
      ] => {
        groups.push(REdit::Normal(prev))
        groups.push(REdit::Replace(old~, new~))
        <del>groups.push(REdit::Normal(next))</del>
        edits = rest
      }
      [edit, .. rest] => {
        groups.push(REdit::Normal(edit))
        edits = rest
      }
    }
  }
  return groups
}
</code></pre>

<pre><code>
///|UUID(e9c1b971-0da7-425d-87f6-520910e5a22b)
pub fn line_group(old : String, new : String) -> Array[REdit] {
  let groups = Array::new()
  let mut old = old.split("\n").collect()[:]
  while old is [.. rest, ""] {
    old = rest
  }
  let mut new = new.split("\n").collect()[:]
  while new is [.. rest, ""] {
    new = rest
  }
  let mut edits = @compress.compress_edits(@myers.diff(old~, new~))[:]
  if edits
    is ([Delete(old~), Insert(new~), .. rest]
    | [Insert(new~), Delete(old~), .. rest]) {
    groups.push(REdit::Replace(old~, new~))
    edits = rest
  }
  while true {
    match edits {
      [] => break
      [Delete(old~), Insert(new~)] | [Insert(new~), Delete(old~)] => {
        groups.push(REdit::Replace(old~, new~))
        break
      }
      [Equal(..) as prev, Insert(new~), Delete(old~), .. rest]
      | [Equal(..) as prev, Delete(old~), Insert(new~), .. rest] => {
        groups.push(REdit::Normal(prev))
        groups.push(REdit::Replace(old~, new~))
        edits = rest
      }
      [edit, .. rest] => {
        groups.push(REdit::Normal(edit))
        edits = rest
      }
    }
  }
  return groups
}
</code></pre>
</body>
</html>
